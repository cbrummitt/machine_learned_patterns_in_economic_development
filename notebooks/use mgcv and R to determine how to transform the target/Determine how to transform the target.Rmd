---
title: "Determine how to transform the target"
author: "Charlie Brummitt"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(mgcv)
```

## Load the data

First, load in the data for Rpop (another name for what is called "absolute advantage" in the paper) by reading in the CSV file generated by the Jupyter notebook "Create_figures.ipynb":

```{r}
Rpop = read.csv("../data_for_use_with_mgcv_in_R/Rpop__data_target__pca_2__target_is_difference_True.csv", header=TRUE)
```

## Analysis

### Create GAM model

First, we define the three GAMs used in the paper, with a cubic regression spline basis (a.k.a. CRS, `bs="cr"`) of rank 30. Rank 30 is sufficiently large so that the model can have high variance, but the smoothing parameter reduces the variance of the model.

```{r}
rank = 30
basis = "cr"
cs_pc0 = gam(
  change_in_pc0 ~ (s(pc0_last_year, bs=basis, k=rank)
                   + s(pc1_last_year, bs=basis, k=rank)
                   + s(log10_gdp_per_capita_constant2010USD_last_year, bs=basis, k=rank)),
  data = Rpop)
cs_pc1 = gam(
  change_in_pc1 ~ (s(pc0_last_year, bs=basis, k=rank)
                   + s(pc1_last_year, bs=basis, k=rank)
                   + s(log10_gdp_per_capita_constant2010USD_last_year, bs=basis, k=rank)),
  data = Rpop)
cs_gdp = gam(
  change_in_log10_gdp_per_capita_constant2010USD ~ (
      s(pc0_last_year, bs=basis, k=rank)
      + s(pc1_last_year, bs=basis, k=rank)
      + s(log10_gdp_per_capita_constant2010USD_last_year, bs=basis, k=rank)),
  data = Rpop)
```

### Analyze significance of terms


In the GAM for predicting the change in the score on the first principal component, we find that all three terms are significant (p-value < 1e-9):
```{r}
summary(cs_pc0)
```

In the GAM for predicting the change in the score on the second principal component, we find that only the score on the first principal component is significant at the 5% level:
```{r}
summary(cs_pc1)
```

In the GAM for predicting the change in the log-base-10 of per-capita incomes, we find that all three terms are significant at the 1% level:
```{r}
summary(cs_gdp)
```

### Check each of the GAMs

The `mgcv` package has a function `gam.check` that visualizes the residuals, a quantile-quantile plot, and more. In all three GAMs, the plots suggest that the tails of the residuals are heavy and that the "sholders" are narrow (compared to a normal distribution). These plots suggest that may want to apply (1/4)th root or square root to the response.

#### Check the GAM that predicts the change in the score on the first principal component

Notice in particular the deviation from the red line in the quantile-quantile plot (top-left plot), especially in the tails:

```{r echo=FALSE}
gam.check(cs_pc0)
```

#### Check the GAM that predicts the change in the score on the second principal component

Again, the quantile-quantile curve (top-left plot) differs significantly from a straight line in the tails:

```{r echo=FALSE}
gam.check(cs_pc1)
```

#### Check the GAM that predicts the change in the log-base-10 of per-capita incomes

For the equation that predicts changes in (log) GDP per capita, the quantile-quantile curve (top-left plot) also differs significantly from a straight line in the tails:

```{r echo=FALSE}
gam.check(cs_gdp)
```


## Transform the target with square root while preserving the sign

The results of `gam.check` above suggest that for all three GAMs we should try transforming the target to bring in the tails. Here we try the square root. To preserve the sign, we multiply the square root of the target by the `sign` of the target.

#### Transform the target for the GAM that predicts the change in the score on the first principal component

```{r}
root = 0.5
cs_pc0_root = gam(abs(change_in_pc0)^root * sign(change_in_pc0) ~ s(pc0_last_year, bs=basis, k=rank) + s(pc1_last_year, bs=basis, k=rank) + s(log10_gdp_per_capita_constant2010USD_last_year, bs=basis, k=rank), data = Rpop)
```

Now the quantile-quantile plot looks much more straight:
```{r}
gam.check(cs_pc0_root)
```

#### Transform the target for the GAM that predicts the change in the score on the second principal component

```{r}
cs_pc1_root = gam(abs(change_in_pc1)^root * sign(change_in_pc1) ~ s(pc0_last_year, bs=basis, k=rank) + s(pc1_last_year, bs=basis, k=rank) + s(log10_gdp_per_capita_constant2010USD_last_year, bs=basis, k=rank), data = Rpop)
```

Again, the quantile-quantile plot now looks much more straight:
```{r}
gam.check(cs_pc1_root)
```

#### Transform the target for the GAM that predicts the change in the log-base-10 of per-capita incomes

```{r}
cs_gdp_root = gam(abs(change_in_log10_gdp_per_capita_constant2010USD)^root * sign(change_in_log10_gdp_per_capita_constant2010USD) ~ s(pc0_last_year, bs=basis, k=rank) + s(pc1_last_year, bs=basis, k=rank) + s(log10_gdp_per_capita_constant2010USD_last_year, bs=basis, k=rank), data = Rpop)
```

Again, the quantile-quantile looks more straight:
```{r}
gam.check(cs_gdp_root)
```


These results suggest that we should transform all three targets with the sign-preserving square root.

### Create and save a figure of the QQ plots

Finally, we create and save a figure that illustrates why we chose to apply the square root to the target:

```{r}
make_qq_plot <- function(data, filename, path.to.directory, rank, root = 0.5, title.font.size = 0.9) {
  basis = "cr" # cubic regression spline (CRS)
  cs_pc0 = gam(change_in_pc0 ~ s(pc0_last_year, bs=basis, k=rank) + s(pc1_last_year, bs=basis, k=rank) + s(log10_gdp_per_capita_constant2010USD_last_year, bs=basis, k=rank), data = data)
  cs_pc1 = gam(change_in_pc1 ~ s(pc0_last_year, bs=basis, k=rank) + s(pc1_last_year, bs=basis, k=rank) + s(log10_gdp_per_capita_constant2010USD_last_year, bs=basis, k=rank), data = data)
  cs_gdp = gam(change_in_log10_gdp_per_capita_constant2010USD ~ s(pc0_last_year, bs=basis, k=rank) + s(pc1_last_year, bs=basis, k=rank) + s(log10_gdp_per_capita_constant2010USD_last_year, bs=basis, k=rank), data = data)
  cs_pc0_root = gam(abs(change_in_pc0)^root * sign(change_in_pc0) ~ s(pc0_last_year, bs=basis, k=rank) + s(pc1_last_year, bs=basis, k=rank) + s(log10_gdp_per_capita_constant2010USD_last_year, bs=basis, k=rank), data = data)
  cs_pc1_root = gam(abs(change_in_pc1)^root * sign(change_in_pc1) ~ s(pc0_last_year, bs=basis, k=rank) + s(pc1_last_year, bs=basis, k=rank) + s(log10_gdp_per_capita_constant2010USD_last_year, bs=basis, k=rank), data = data)
  cs_gdp_root = gam(abs(change_in_log10_gdp_per_capita_constant2010USD)^root * sign(change_in_log10_gdp_per_capita_constant2010USD) ~ s(pc0_last_year, bs=basis, k=rank) + s(pc1_last_year, bs=basis, k=rank) + s(log10_gdp_per_capita_constant2010USD_last_year, bs=basis, k=rank), data = data)
  
  pdf(paste(path.to.directory, paste(filename, ".pdf", sep = ""), sep = ""), width=6.8, height=4)
  par(mfrow=c(2,3), mai=c(.6, 0.6, 0.45, 0.25)) # bottom, left, top, right
  qq.gam(cs_pc0, main=expression(paste("Predict score on 1st principal component")), cex.main=title.font.size)
  qq.gam(cs_pc1, main=expression(paste("Predict score on 2nd principal component")), cex.main=title.font.size)
  qq.gam(cs_gdp, main=expression(paste("Predict ", log[10], "(GDP per capita)")), cex.main=title.font.size)
  qq.gam(cs_pc0_root, main=expression(paste("Predict (score on 1st principal comp.)"^(1/2))), cex.main=title.font.size)
  qq.gam(cs_pc0_root, main=expression(paste("Predict (score on 2nd principal comp.)"^(1/2))), cex.main=title.font.size)
  qq.gam(cs_gdp_root, main=expression(paste("Predict (", log[10], "(GDP per capita))"^(1/2))), cex.main=title.font.size)
  dev.off()
}
make_qq_plot(Rpop, "QQ_Rpop", "../../figures/", 30)
```